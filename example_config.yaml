# ------------------------------------------------------------------------------
# dproxy Example Configuration
# ------------------------------------------------------------------------------
# This file demonstrates common use cases.
# ------------------------------------------------------------------------------

logging:
  level: "INFO"
  outputs: ["console"]

server:
  listeners:
    # Standard DNS for local network devices
    - address: "0.0.0.0"
      port: 53
      protocol: "udp"
    
    # Encrypted DNS listener (DoT) for secure clients
    - address: "0.0.0.0"
      port: 853
      protocol: "dot"

  # dproxy will generate a self-signed cert if these are empty
  tls:
    cert_file: ""
    key_file: ""
    
  # Enable DDR so clients can auto-upgrade to encrypted DNS
  ddr:
    enabled: true

# Use ARP to identify devices on the LAN by MAC address
arp:
  mode: "both"

# --- SMART RATE LIMITING ---
# Defend against abuse and system overload
rate_limit:
  enabled: true
  client_qps: 100            # Allow 100 queries per second per client
  client_burst: 200          # Allow bursts up to 200
  
  # System Load Throttling
  max_goroutines: 5000       # Soft limit: Start adding delay (50ms -> 1s)
  hard_max_goroutines: 8000  # Hard limit: Drop queries immediately

cache:
  enabled: true
  size: 50000
  hosts_cache_dir: "/tmp/dproxy_cache" # Persist heavy blocklists to disk
  min_ttl: 300 # Enforce a minimum 5-minute cache to reduce chatter

routing:
  # 1. Define your Upstreams
  upstream_groups:
    # Fast, encrypted public DNS
    cloud_dns:
      - "doh://1.1.1.1/dns-query"
      - "doh://8.8.8.8/dns-query"
    
    # Internal company DNS (Plain UDP)
    internal_dns:
      - "udp://10.0.0.5:53"
      - "udp://10.0.0.6:53"

    # Family Friendly DNS (Filters adult content)
    family_safe:
      - "doh://family.cloudflare-dns.com/dns-query"

  # 2. Define Routing Logic
  routing_rules:
    # Scenario A: Ad-Blocking (The "Pi-hole" replacement)
    # Blocks ads for everyone using a remote blocklist.
    - name: "AdBlock"
      match:
        # No specific match conditions = applies to all queries checking this list
        # We rely on the hosts_files to return 0.0.0.0
        query_domain: ["*"] 
      # We don't actually forward these, the hosts file handles it. 
      # But we need a fallback just in case the hosts file doesn't match.
      upstreams: cloud_dns 
      hosts_urls:
        - "https://raw.githubusercontent.com/StevenBlack/hosts/master/hosts"
      hosts_wildcard: true
      hosts_optimize: true
      refresh_interval: "24h"

    # Scenario B: Split Horizon / Local Dev
    # Routes any query for *.corp or *.lan to the internal DNS server.
    - name: "Corporate VPN"
      match:
        query_domain: ["*.corp", "*.lan", "internal.company.com"]
      upstreams: internal_dns
      strategy: "failover" # Try first server, then second

    # Scenario C: Full Recursion
    # Routes queries for specific secure zones to the internal recursive resolver
    - name: "Secure Zone"
      match:
        query_domain: ["*.secure.example.com"]
      upstreams: "RECURSIVE"

  # 3. Default Fallback
  # If none of the above match, do this:
  default:
    upstreams: cloud_dns
    strategy: "fastest" # Race them and pick the winner
    hosts_files: 
      - "/etc/hosts" # Always load local system hosts

